<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width" initial-scale="1">
    <title>Too many ssh-agents and the keychain - jimkang.com
    </title>
    <link rel="alternate" href="http://jimkang.com/weblog/feed.xml" type="application/rss+xml" title="It's dot com.">
    <link rel="stylesheet" href="/weblog/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <!-- include author-->
        <h1>Too many ssh-agents and the keychain</h1>
        <!-- p.author-->
        <!--  | #{ "Written by " }-->
        <!--  mixin author(page.metadata.author)-->
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>This is the tale of three really simple and reliable tools, rsync, cron, and keychain, combining to create some confounding emergent&nbsp;complexity.</p>
<p><span class="more"></span></p>
<p><a href="https://linux.die.net/man/1/ssh-agent"><code>ssh-agent</code></a> is a daemon that holds onto your credentials so that you only have to enter a password once a session. Once you’ve entered your password for your private key once via <code>ssh-add</code>, <code>ssh-agent</code> decrypts your private key and holds onto it. Whenever another program needs something to be done with a private key, it asks <code>ssh-agent</code> to do it. <code>ssh-agent</code> passes the results of that operation to the client program instead of letting it have the unencrypted private&nbsp;key.</p>
<p>Some limitations of <code>ssh-agent</code> are:</p>
<ul>
<li>When the user logs out, <code>ssh-agent</code> may shut down, and the user will have to run <code>ssh-add</code> again.</li>
<li>Cron jobs and other automated processes don’t have access to the agent, and thus, need to find another way to provide credentials for their&nbsp;tasks.</li>
</ul>
<p>On many Linux distros, there is a <a href="https://linux.die.net/man/1/keychain"><code>keychain</code></a> program that will keep the same <code>ssh-agent</code> running across logins and also publishes information about it so that other programs (including those running in cron jobs) can get at&nbsp;it.</p>
<h2 id="scheduling-authentication-requiring-tasks-with-cron">Scheduling authentication-requiring tasks with&nbsp;cron</h2>
<p>I was trying to get cron to run a bash script that ran <code>rsync</code> to copy a directory on a remote machine to a local&nbsp;directory.</p>
<p>This didn’t work. In the context of the cron job, I kept getting <code>Permission denied (publickey)</code> from the <code>rsync</code> command.</p>
<p>After sshing into the remote machine to trigger a login and get my password into <code>ssh-agent</code>, I ran the script directly in the terminal, and it worked without&nbsp;prompting.</p>
<blockquote>
<p>Something I forgot (for a while) is that <em>I did not do this in a login shell</em>. In order to simulate the cron environment, I ran <code>sh</code>, and ran the script in that&nbsp;shell.</p>
</blockquote>
<p>It still failed via cron job, though. I thought that <code>ssh-agent</code> would have the unencrypted private key it would need at that point, but clearly something was still&nbsp;wrong.</p>
<h3 id="the-environment">The&nbsp;environment</h3>
<p>In my script, I had a line like this, which I thought would let my script get access to <code>ssh-agent</code>:</p>
<pre><code>~/.keychain/machinename-sh
</code></pre><p>That file, which is generated by <code>keychain</code>, is a shell script that exports two environment&nbsp;variables:</p>
<ul>
<li><code>SSH_AGENT_PID</code></li>
<li><code>SSH_AUTH_SOCK</code></li>
</ul>
<p>The process id and the socket are what programs need to communicate with <code>ssh-agent</code>. When I echoed those variables in my script, they were empty. When the script ran rsync, I got prompted for credentials. (This is a problem because you can’t be around to enter credentials for most automated&nbsp;tasks.)</p>
<p>When I updated the script to use <code>source ~/.keychain/machinename-sh</code>, those variables were filled out and pointed to an existing process and an existing sock file. (I don’t have a good explanation for why <code>source</code> worked, but running the keychain file as a script didn’t&nbsp;work.)</p>
<p>However, it still failed with “Permission denied” when I ran it via cron. I was able to log those two environment variables, and they still referred to things that&nbsp;existed.</p>
<p>After hours of failed attempts to flush out information that could tell me what was going on, I ran <code>ps aux | grep ssh-agent</code> again. I noticed that <em>the <span class="caps">PID</span> of the <code>ssh-agent</code> that I used from the successful manual run <strong>was <span class="caps">NOT</span> from the PID in <code>SSH_AGENT_PID</code></strong></em>.</p>
<p>The <code>ssh-agent</code> in this env var seemed to not have my&nbsp;key.</p>
<p>So, I logged out of the host machine in all terminals (I had three), then logged back in, and <code>keychain</code> ran when I logged in. I then ran <code>ssh-add</code> to add my key. I made sure there were no other <code>ssh-agent</code> processes&nbsp;running.</p>
<p>Then, the script ran via the cron job, and the <code>rsync</code> command worked. The <span class="caps">PID</span> that the script logged matched that of the single <code>ssh-agent</code> running.</p>
<p>What I think happened was&nbsp;this:</p>
<ul>
<li>The first time I logged in to the host machine, <code>keychain</code> ran, but I did not, directly or indirectly, <code>ssh-add</code> my key.<ul>
<li><code>keychain</code> wrote the <code>ssh-agent</code> <span class="caps">PID</span> and socket into <code>~/keychain/machinename-sh</code>.</li>
</ul>
</li>
<li>I then logged into another terminal, but then start an <code>sh</code>shell &mdash; <em>a non-login shell which did not run <code>keychain</code></em>.<ul>
<li>There a new <code>ssh-agent</code> was&nbsp;started.</li>
<li>My key was added to that&nbsp;one.</li>
<li>The script ran successfully (when run directly, outside of cron), using that&nbsp;ssh-agent.</li>
</ul>
</li>
<li>I fixed the script’s importing of the keychain environment variables, but they referred to an <code>ssh-agent</code> (the first one) that did not have the key added to&nbsp;it.</li>
<li>When run via cron, the script ran <code>rsync</code> which asked <code>ssh-agent</code> to log into the remote server, but the key for it was in a different <code>ssh-agent</code> process, not that one. So, it failed with <code>Permission denied (publickey)</code>.</li>
</ul>
<p>So, make sure you track your <code>ssh-agent</code>s (try to have only one) and pay attention to <code>ssh-agent</code> <code>keychain</code> is pointing clients&nbsp;at.</p>
<p>#linux #unix #auth #keychain #ssh&nbsp;#cron</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/weblog/">« Full blog</a></div>
        <!--section.about-->
        <!--  !=contents['about.md'].html-->
        <section class="copy">
          <p>&copy; 2023 <a href="http://jimkang.com">Jim Kang</a> &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
          <p><a href='/weblog/feed.xml'><strong>RSS feed.</strong></a> And good for you for still using RSS!</p>
        </section>
      </div>
    </footer>
  </body>
</html>